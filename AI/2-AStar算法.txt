1.A*算法目的在于找到一条能够到达目的地的最短路线，其核心思想是广度优先搜索，以当前格子为中心，遍历周围的格子，通过计算每个格子到达目标点的距离，找出一条能够到达且消耗最小的路径。A*算法中的公式很简单：F =G+H，我是这样理解的： 
如图，假设角色需要从A点移动到B点。G代表从A点移动到自身相邻的八个点（A1到A8）所消耗的体力值，因为正方向比斜方向移动的距离短，所以正方向消耗10点体力（A到A5），斜方向消耗14点体力（A到A3）；H代表从当前点到终点的横纵坐标之差的绝对值，即曼哈顿距离（从A到B为40，从A5到B为30）。也可以这样理解：G为单次行走消耗的体力值，H表示到达终点还将需要消耗的体力值。当某个点受到阻挡时，需返回到之前的点重新计算。这样一来，地图上每一个格子所代表的点到达终点需要消耗的体力值都被量化，下一步我们要做的事情就是找到一条消耗体力值F最小的路径。 
g(n)表示从初始结点到任意结点n的代价，h(n)表示从结点n到目标点的启发式评估代价

2.网格地图中的启发式算法
A.曼哈顿距离
标准的启发式函数是曼哈顿距离（Manhattan distance）。考虑你的代价函数并找到从一个位置移动到邻近位置的最小代价D。因此，我的游戏中的启发式函数应该是曼哈顿距离的D倍：
       H(n) = D * (abs ( n.x C goal.x ) + abs ( n.y C goal.y ) )

B.对角线距离
如果在你的地图中你允许对角运动那么你需要一个不同的启发函数。（4 east, 4 north）的曼哈顿距离将变成8*D。然而，你可以简单地移动（4 northeast）代替，所以启发函数应该是4*D。这个函数使用对角线，假设直线和对角线的代价都是D：

h(n) = D * max(abs(n.x - goal.x), abs(n.y - goal.y))

C.欧几里得距离
如果你的单位可以沿着任意角度移动（而不是网格方向），那么你也许应该使用直线距离：

h(n) = D * sqrt((n.x-goal.x)^2 + (n.y-goal.y)^2)

