1.什么是draw call
draw call本身的含义很简单：cpu调用图像编程接口，以命令GPU进行渲染操作。
常见误区：draw call中造成性能问题的元凶是GPU，认为GPU上的状态切换时耗时的，其实真正拖后腿的是CPU。

2.CPU和GPU是如何实现并行工作的
如果没有流水线化，那么CPU需要等到GPU完成上一个渲染任务才能再次发送渲染指令，我们需要让CPU和GPU可以并行工作，解决方法就是使用一个命令缓冲区--command buffer。
命令缓冲区包含了一个命令队列，由CPU向其中添加指令，而由GPU从中读取命令，添加和读取的过程是互相独立的。命令缓冲区使得CPU和GPU可以相互独立工作。当CPU需要渲染一些对象时，它可以向命令缓冲区中添加命令，而当GPU完成了上一次的渲染任务后，它就可以从命令队列中再取出一个命令执行它。
命令缓冲区中的命令有很多种类，drawcall只是其中一种，其他命令还有改变渲染状态等。

3.为什么drawcall多了会影响帧率
举个例子：创建10000个小文件，每个1k，将其复制到另一个文件夹，可以发现，尽管这些文件的空间不超过10MB，但是要花费很长时间，现在，再来创建一个单独的文件，它的大小是10MB，然后也把它从一个文件夹复制到另一个文件夹，这次时间却很多。
原因：每一个复制操作需要很多额外的操作，例如分配内存、创建各种元数据等，这些操作将造成很多额外的性能开销。
每次调用Drawcall之前，CPU需要向GPU发送很多内容，包括数据、渲染状态和命令等。在这一阶段，CPU需要完成很多准备工作，一旦完成这些准备工作，gpu就可以开始本次渲染，GPU的渲染能力很强，渲染200个和2000个没有什么区别，因此渲染速度取决于CPU提交命令的速度。如果Drawcall的数量太多，CPU就会把大量时间花费在提交drawcall上，造成CPU的过载。

4.如何减少drawcall
减少drawcall的方法有很多，这里讨论批处理办法。
批处理的思想：提交大量很小的drawcall会造成CPU的性能瓶颈，即CPU把时间都花费在准备drawcall的工作上了，一个很显然的优化思路就是把很多小的drawcall合并成一个大的drawcall。
需要注意的是：由于我们需要在CPU的内存中合并网格，而合并的过程是消耗时间的，因此，批处理更是适合于那些静态的物体，只需要合并一次即可。我们也可以对动态物体进行批处理，但是由于这些物体时不断运动的，因此每一帧都需要重新进行合并然后再发送给GPU，这对时间和空间都会造成一定的影响。
在游戏开发中，为避免减少drawcall的开销，有两点需要注意：
a.避免使用大量很小的网格，当不可避免地使用很小的网格结构时，考虑是否可以合并它们。
b.避免使用过多的材质，尽量在不同的网格之间共用同一个材质。
