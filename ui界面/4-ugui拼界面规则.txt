UGUI的层叠顺序是按照Hierarchy中的顺序从上往下进行的，也就是越靠上的组件，就会被画在越底部。所以UI就是这样一层一层地叠上去画出来的。当然这样一个一个地画效率肯定是不能接受的，所以要合并，要Batch，自身就提供了一个算法去决定哪些层应该合并到一起，并以什么样的顺序进行绘制。所有相邻层的可Batch的UI元素将会在一个Drawcall完成。接下来就来讨论一下Unity的层级合并与计算算法。

Unity的UI渲染顺序的确定有2个步骤，第一步计算每个UI元素的层级号；第二步合并相同层级号中可以Batch的元素作为一个批次，并对批次进行排序；

计算层级号的算法：

1,如果有一个UI元素，它所占的屏幕范围内（通常是矩形），如果没有任何UI在它的底下，那么它的层级号就是0（最底下）；

2,如果有一个UI在其底下且该UI可以和它Batch，那它的层级号与底下的UI层级一样；

3,如果有一个UI在其底下但是无法与它Batch，那它的层级号为底下的UI的层级+1；

4,如果有多个UI都在其下面，那么按前两种方式遍历计算所有的层级号，其中最大的那个作为自己的层级号。

合并批次：

1.Unity会将每一层的所有元素进行一个排序（按照材质、纹理等信息），合并掉可以Batch的元素成为一个批次。

2.Text组件会排在Image组件之前渲染。

3.Unity会再做一个优化，即如果相邻间的两个批次正好可以Batch的话就会进行Batch。

例1：

一个层级为0的ImageA，一个层级为1的ImageB（2个Image可Batch）和一个层级为0的TextC。

Unity排序后的批次为TextC->ImageA->ImageB，后两个批次可以合并，所以是2个Drawcall。

例2：

一个层级为0的TextD，一个层级为1的TextE（2个Text可Batch）和一个层级为0的ImageF。

Unity排序后的批次为TextD->ImageF->TextE，这时就需要3个Drawcall了！





总结：

1.有相同材质和纹理的UI元素是可以Batch的，可以Batch的UI上下叠在一块不会影响性能，但是如果不能Batch的UI元素叠在一块，就会增加Drawcall开销。

2.尽量让同一个材质球上的东西 放在同一级上。

3.有些情况可以考虑人为增加层级从而减少Drawcall，比如一个Text的层级为0，另一个可Batch的Text叠在一个图片A上，层级为1，那此时2个Text因为层级不同会安排2个Drawcall，但如果在第一个Text下放一个透明的图片（与图片A可Batch），那两个Text的层级就一致了，Drawcall就可以减少一个。

4.应该尽量避免使用Mask，其实Mask的功能有些时候可以变通实现，比如设计一个边框，让这个边框叠在最上面，底下的UI移动时，就会被这个边框遮住。

5. z 值 保持为0。