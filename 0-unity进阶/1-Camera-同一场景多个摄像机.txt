1.理解颜色缓冲区和深度缓冲区
颜色缓冲区：就是帧缓冲区（图形设备的内存），需要渲染的场景的每一个像素都最终写入该缓冲区，然后由它渲染到屏幕上显示。
深度缓冲区：与帧缓冲区对应，用于记录上面每个像素的深度值，通过深度缓冲区，我们可以进行深度测试，从而确定像素的遮挡关系，保证渲染正确。

2.什么是Unity中的摄像机？
在我们继续讨论这个话题之前, 你必须明白Unity的摄像机到底是什么。当Unity渲染场景的时候，它需要大量的重要信息被设置好，但是让我们简化下这些需要提前设置好的重要信息的列表使其更加容易理解。我们要考虑的重要信息有：
A.要渲染的物体的列表
B.摄像机的视角（以及摄像机的位置、旋转、缩放、视野、裁剪等等）

要渲染的物体的列表就是场景中的所有物体，是不是这样？错了！每个摄像机只会渲染那些对它来说是可见的物体（依据视野、视野锥体剔除等等）以及那些实际在指定摄像机可见的层上的物体。

摄像机的渲染顺序：深度。深度限定了摄像机渲染的顺序。深度数值较小的摄像机将会比深度数值较大的摄像机先进行渲染。

3.摄像机在渲染什么？
你能看到的是最后作为结果输出的图像（让我们称它为颜色缓冲区）。当然还有一些东西是你看不到，这个看不到的东西被称为深度缓冲区（也被称为z buffer）。
深度缓冲区可以很容易的被描述为一个游戏屏幕大小的灰度图像，这个图像中的每个像素都代表着这个像素到摄像机到底有多远（实话实说这个解释不是100%正确的，但是我们认为现在不应该为了追求准确性而把这个概念解释的过于复杂）。深度缓冲区是由显卡的GPU来使用的，用来决定要被渲染的像素是否应该被处理还是应该从渲染中移除。结果就是，会被其他像素遮挡住的像素不会是可见的。

当你使用多个摄像机的时候，每一个摄像机都将自己的颜色和深度信息存储在缓冲区中，还将积累大量的每个摄像机的渲染数据。当场景中的任何特定摄像机进行渲染时，你可以设定清除标记以清除缓冲区信息的不同集合。如果不清除，那么该摄像机就会得到上个相机的缓冲区数据。

4.depth
相机的深度值，depth越小会越先渲染，在画面中会越靠后，depth越大的会后渲染，在画面中会越靠前。
Clear Flags
每一个相机在开始渲染前，都需要对当前RenderBuffer中的颜色缓冲区(ColorBuffer)和深度缓冲区(Z-Buffer)进行是否清除的操作，这个选项控制了清除及清除后的内容。
下面将展示一下不同Clear Flags设置下的区别：

Sky box：清除颜色缓冲区和深度缓冲区，并将颜色缓冲区设置为天空盒的颜色。

Solid Color：清除颜色缓冲区和深度缓冲区，并将颜色缓冲区设置为一个固定的颜色。
上述两种选项是最容易理解的，只是直接清除了缓冲区内的颜色和深度数据，因此如果场景中存在多个相机，且最后一个相机被设置为上述两种ClearFlags，那么，呵呵，之前的相机绘制结果将无法直接显示(因为都被清掉了)。

Depth Only：保留颜色缓冲区，仅清除深度缓冲区。

很容易发现，由于拍蓝色立方体的蓝色相机后绘制，且不清除颜色缓冲区，因此蓝色相机在绘制之前，颜色缓冲区已经被红色相机所拍的结果：SolidColor + 红色立方体所填充，因此蓝色立方体只是在这基础之上进行的绘制。
并且，由于清除了深度缓冲区，蓝色立方体无论空间是否被红色立法体遮挡，总会任性的全部绘制，因此产生了错误的遮挡效果。

Don't Clear：什么都不清除

同上，颜色缓冲区在保留的同时，也保留了深度缓冲区，这样蓝色相机在绘制时，就会被红色立方体的深度值所影响，因此获得了正确的遮挡效果。
对了，如果只有一个相机，并且这个相机还设置了“DepthOnly”或者“Don'tClear“的选项，也就是不清除颜色缓冲区，那么当你拖动一个物体时，就会产生这种重影效果。
这种情况的出现是因为在帧与帧切换的过程中颜色缓冲区没有被清空（在之前帧所渲染的颜色缓冲区的内容没有清除，所以转移到下一帧中来了，而且因为一直没有清除，所以一直累加，就出现了上图中的那些奇怪的形状），深度缓冲区的内容同样也没有清除。这种情况的出现是因为在帧与帧切换的过程中颜色缓冲区没有被清空（在之前帧所渲染的颜色缓冲区的内容没有清除，所以转移到下一帧中来了，而且因为一直没有清除，所以一直累加，就出现了上图中的那些奇怪的形状），深度缓冲区的内容同样也没有清除。
如果不清除深度缓冲，那么即使在当红A在绿B前面时，如果上下移动红A，那么红A会覆盖绿B，然后如果把红A向上移动，把B露出来，这是虽然相机能看到B，但是不会渲染出来，因为深度缓冲区没有被清除，它的深度值还是A的，所以在深度检测时，还是只会显示出红A，而显示不出绿B。如果清除了深度缓冲区，那么颜色会出现保留，即当红A移动时，红A的颜色会被保存，但是深度信息是清除的，如果红A遮挡了绿B之后又离开，那么此时深度缓冲区为空，就会把B渲染上去。如果是skybox和solid 
color，那么每次渲染之前就是全部清除的，颜色缓冲区会被相应填充。