1.当在协程内部停止自身后，后面的代码块还会继续执行，直到遇到yield语句才会终止。
 经测试：停止协程，意味着就是停止yield，所以在停止协程后，yield之后的语句也就不会执行了，单是yield之前的语句会执行。
2.协程能够中断执行当前的代码（通过yield语句），直到中断指令结束。
  中断只是针对于该协程函数，对其他函数没有任何的影响
  当开启协程后，每个yield语句只会产生一次中断（可以理解为一次性的），下一次再开启协程时，将不会有中断。
3.yield return null; //等待下一帧中的Update函数执行完之后再继续执行。注意:指所有的Update函数。
4.yield return new WaitForSeconds(10);  //延迟10秒之后再执行，受到Time.timeScale影响
5.yield return new WaitForFixedUpdate();  //等待所有脚本中的FixedUpdate()函数结束再继续执行
6.yield return StartCoroutine(MyFunc());  //等待协程MyFunc()结束后再执行

7.协程 (Coroutine) 是大部分现代编程环境都提供的一个非常有用的机制。它允许我们把不同时刻发生的行为，在代码中以线性的方式聚合起来。
Unity 内的协程实现是传统协程的简化――在主线程内每一帧给定的时间点上，引擎通过一定的调度机制来唤醒和执行满足条件的协程，以实际上的分时串行化执行回避了协程之间的通信问题。
协程是同步执行的，同一时间只能执行某一协程。

8.使用协程要注意yield语句的位置尽量放置在最后。
尤其是带循环的yield语句，如果把yield放在前面，那么很可能导致循环条件不满足时，while循环体依旧执行。例如，在条件满足时，将协程挂起两秒，但是在这两秒内，条件变成了false，那么两秒后，程序还是会执行，这时候就可能会出错。
技巧总结：协程的逻辑，要去判断两个yield之间的代码逻辑是否合理，比如上面那个例子，两个yield之间，是先执行代码，再判断条件，肯定是不合逻辑的。